# 互斥和同步

## 互斥

多线程之间需要有互斥保护共享着的资源

* 自旋锁
  
  * 概念：自旋锁（spin lock） 是一种典型的对临界资源进行互斥访问的手段，`主要针对的是SMP以及单CPU但是内核可抢占的情况`
    
    * 这里注意如果是单CPU，一定需要内核可抢占，不然会一直自旋，死等了
  
  * 如果锁被占用了，即会进行自旋，死等
  
  * 实际上自旋锁一般的实现是：
    
    * 测试并设置，test_and_set
    
    * 比较并交换，compare_and_swap
    
    * 总的来说动作是load_and_store，即先读再写，并且load和store的动作是原子操作
  
  * 优势：
    
    * 上下文切换开销低，线程不挂起/唤醒
  
  * 缺点：
    
    * 单核CPU不适合，有可能死锁
    
    * 如果临界区过长，会浪费CPU时间
  
  * 综上
    
    * 自旋锁适合，`短临界区、多核系统`

* 互斥锁

* 总结：

| 特性    | 自旋锁 spin_lock | 互斥锁 mutex   |
| ----- | ------------- | ----------- |
| 是否阻塞  | 不阻塞，忙等待       | 阻塞，线程进入休眠状态 |
| 适用场景  | 短临界区、多核系统     | 任意长度临界区     |
| 上下文开销 | 无             | 有           |

## 同步

生产者消费者问题，使用信号量、条件变量、互斥锁都可以实现同步

### 做一个实际问题

* 生产者：打印左括号"("

* 消费者：打印右括号")"

* 限制条件：

> 必须先有左括号，才能有右括号，并且任意时刻，右括号的数量不能多于左括号，否则语法错误

### 信号量

* 信号量实际上是通过`计数器`对共享资源进行控制，只有计数器>0时，共享资源才允许被线程访问

* 操作系统中的PV操作
  
  * P: passeren，通过，申请资源
    
    * 如果信号量S的值大于0，则线程获得通信证，并计数-1
    
    * 如果S为0，则进行等待，直到V操作唤醒
  
  * V: vrigeven，释放
    
    * 释放资源，信号量S+1

* 代码：

```cpp
#include "thread.h"
#include "thread-sync.h"

sem_t full, empty;
//empty用来管理生产者，当缓冲区满时，等待空位置再生产
//full用来管理消费者，当缓冲区空时，等待有数据在消费

void producer() {
  while (1) {
    //p是等，所以这里是等待空位置
    P(&empty);
    printf("(");
    V(&full);
  }
}

void consumer() {
  while (1) {
    //p是等，所以这里是等待有东西
    P(&full);
    printf(")");
    V(&empty);
  }
}

int main(int argc, char *argv[]) {
  assert(argc == 2);
  SEM_INIT(&full, 0);
  SEM_INIT(&empty, atoi(argv[1]));
  for (int i = 0; i < 8; i++) {
    create(producer);
    create(consumer);
  }
}
```

* <mark>为什么这里要用两个信号量？</mark>
  
  * 因为一个信号量的PV只能判断是空了还是满了，但是不知道当前是在消费者还是生产者线程中
    
    * 例如当信号量为0，你P进行等待，但此时你本来就是生产者线程，理论上这个时候你应该生产的，但是你却一直等待，所以就需要知道当前是producer/consumer，这样逻辑就复杂了
  
  * 所以使用两个信号量
    
    * empty用来给生产者使用，为0的时候代表没有空位置，所以等待
    
    * full用来给消费者，为0的时候代表没有有效数据，所以等待


